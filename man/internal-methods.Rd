% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Class-BindMatrix.R, R/Class-Convert.R,
%   R/Class-Mask.R, R/Class-RankTransform.R, R/Class-TransformScaleShift.R,
%   R/Class-subset.R, R/Method-binarize.R, R/Method-internal.R, R/showtree.R
\name{rbind2,ANY,BPCellsMatrix-method}
\alias{rbind2,ANY,BPCellsMatrix-method}
\alias{rbind2,BPCellsMatrix,ANY-method}
\alias{cbind2,ANY,BPCellsMatrix-method}
\alias{cbind2,BPCellsMatrix,ANY-method}
\alias{rbind2,ANY,BPCellsSeed-method}
\alias{rbind2,BPCellsSeed,ANY-method}
\alias{cbind2,ANY,BPCellsSeed-method}
\alias{cbind2,BPCellsSeed,ANY-method}
\alias{convert_mode,ANY-method}
\alias{mask_matrix,ANY,ANY-method}
\alias{rank_transform,ANY-method}
\alias{/,numeric,BPCellsMatrix-method}
\alias{/,numeric,BPCellsSeed-method}
\alias{*,BPCellsTransformScaleShiftSeed,numeric-method}
\alias{+,BPCellsTransformScaleShiftSeed,numeric-method}
\alias{*,numeric,BPCellsTransformScaleShiftSeed-method}
\alias{+,numeric,BPCellsTransformScaleShiftSeed-method}
\alias{[,BPCellsMatrix,missing,ANY,ANY-method}
\alias{[,BPCellsMatrix,ANY,missing,ANY-method}
\alias{[,BPCellsMatrix,missing,missing,ANY-method}
\alias{[<-,BPCellsSeed,ANY,ANY,matrix-method}
\alias{[<-,BPCellsSeed,ANY,ANY,dgCMatrix-method}
\alias{[<-,BPCellsSeed,ANY,ANY,BPCellsSeed-method}
\alias{<,BPCellsMatrix,numeric-method}
\alias{>,numeric,BPCellsMatrix-method}
\alias{<=,BPCellsMatrix,numeric-method}
\alias{>=,numeric,BPCellsMatrix-method}
\alias{<,BPCellsSeed,numeric-method}
\alias{>,numeric,BPCellsSeed-method}
\alias{<=,BPCellsSeed,numeric-method}
\alias{>=,numeric,BPCellsSeed-method}
\alias{internal-methods}
\alias{seed<-,BPCellsMatrix-method}
\alias{path<-,BPCellsMatrix-method}
\title{House of internal methods}
\usage{
\S4method{rbind2}{ANY,BPCellsMatrix}(x, y, ...)

\S4method{rbind2}{BPCellsMatrix,ANY}(x, y, ...)

\S4method{cbind2}{ANY,BPCellsMatrix}(x, y, ...)

\S4method{cbind2}{BPCellsMatrix,ANY}(x, y, ...)

\S4method{rbind2}{ANY,BPCellsSeed}(x, y, ...)

\S4method{rbind2}{BPCellsSeed,ANY}(x, y, ...)

\S4method{cbind2}{ANY,BPCellsSeed}(x, y, ...)

\S4method{cbind2}{BPCellsSeed,ANY}(x, y, ...)

\S4method{convert_mode}{ANY}(object, mode)

\S4method{mask_matrix}{ANY,ANY}(object, mask, invert = FALSE)

\S4method{rank_transform}{ANY}(object, axis = NULL, offset = TRUE, ...)

\S4method{/}{numeric,BPCellsMatrix}(e1, e2)

\S4method{/}{numeric,BPCellsSeed}(e1, e2)

\S4method{*}{BPCellsTransformScaleShiftSeed,numeric}(e1, e2)

\S4method{+}{BPCellsTransformScaleShiftSeed,numeric}(e1, e2)

\S4method{*}{numeric,BPCellsTransformScaleShiftSeed}(e1, e2)

\S4method{+}{numeric,BPCellsTransformScaleShiftSeed}(e1, e2)

\S4method{[}{BPCellsMatrix,missing,ANY,ANY}(x, i, j, ..., drop = FALSE)

\S4method{[}{BPCellsMatrix,ANY,missing,ANY}(x, i, j, ..., drop = FALSE)

\S4method{[}{BPCellsMatrix,missing,missing,ANY}(x, i, j, ..., drop = FALSE)

\S4method{[}{BPCellsSeed,ANY,ANY,matrix}(x, i, j, ...) <- value

\S4method{[}{BPCellsSeed,ANY,ANY,dgCMatrix}(x, i, j, ...) <- value

\S4method{[}{BPCellsSeed,ANY,ANY,BPCellsSeed}(x, i, j, ...) <- value

\S4method{<}{BPCellsMatrix,numeric}(e1, e2)

\S4method{>}{numeric,BPCellsMatrix}(e1, e2)

\S4method{<=}{BPCellsMatrix,numeric}(e1, e2)

\S4method{>=}{numeric,BPCellsMatrix}(e1, e2)

\S4method{<}{BPCellsSeed,numeric}(e1, e2)

\S4method{>}{numeric,BPCellsSeed}(e1, e2)

\S4method{<=}{BPCellsSeed,numeric}(e1, e2)

\S4method{>=}{numeric,BPCellsSeed}(e1, e2)

\S4method{seed}{BPCellsMatrix}(x) <- value

\S4method{path}{BPCellsMatrix}(object) <- value
}
\arguments{
\item{x, y}{A \link[=BPCellsSeed-class]{BPCellsSeed} or
\link[=BPCellsMatrix-class]{BPCellsMatrix} object.}

\item{...}{Additional parameters passed into specific methods.}

\item{object}{A \link[=BPCellsSeed-class]{BPCellsSeed} or
\link[=BPCellsMatrix-class]{BPCellsMatrix} object.}

\item{mode}{Storage mode of BPCells matrix, one of \code{uint32_t} (unsigned
32-bit integer), \code{float} (32-bit real number), or \code{double} (64-bit real
number). R cannot differentiate 32-bit and 64-bit real number, so
\link[=BPCellsSeed-class]{type} method always return "double" for both \code{float}
and \code{double} mode.}

\item{mask}{Mask matrix, A \link{BPCellsSeed} or \link{BPCellsMatrix} object.
Additionally, a matrix-like object which can be coerced into
\link[Matrix:dgCMatrix-class]{dgCMatrix}.}

\item{invert}{A bool, indicates whether revert the mask.}

\item{axis}{Axis to rank values within. "col" to rank values within each
column, and "row" to rank values within each row. If \code{NULL}, will use the
storage axis of \code{object} (see \link{storage_axis}).  If \code{axis} specified is
different from the storage axis of \code{object}, \link{transpose_axis} will be
used to transpose the underlying storage order.}

\item{offset}{A bool, whether or not to add offset such that the rank of a 0
value is 0. Default: \code{TRUE}.}

\item{e1, e2}{One of \code{e1} or \code{e2} must be \link[=BPCellsSeed-class]{BPCellsSeed} or
\link[=BPCellsMatrix-class]{BPCellsMatrix} object, and the another must be a
number.}

\item{i, j}{Row and Column index.}

\item{drop}{A bool, if \code{TRUE}, any extents of length one will be removed and
return an atomic vector.}

\item{value}{A matrix which can be coerced into
\link[Matrix:dgCMatrix-class]{dgCMatrix}.}
}
\description{
Following methods are used by package internal, for messages purpose, usually
the method for \code{ANY} object.
}
