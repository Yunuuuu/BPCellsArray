% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Class-BPCellsMatrix.R, R/Method-Arith.R,
%   R/Method-BindMatrix.R, R/Method-Compare.R, R/Method-Convert.R,
%   R/Method-Mask.R, R/Method-Math.R, R/Method-RankTransform.R,
%   R/Method-Subassign.R, R/Method-axis.R, R/Method-internal.R, R/Method-pmin.R
\name{DelayedArray,BPCellsDelayedOp-method}
\alias{DelayedArray,BPCellsDelayedOp-method}
\alias{/,numeric,BPCellsMatrix-method}
\alias{\%\%,numeric,BPCellsMatrix-method}
\alias{\%\%,BPCellsMatrix,numeric-method}
\alias{\%/\%,numeric,BPCellsMatrix-method}
\alias{\%/\%,BPCellsMatrix,numeric-method}
\alias{set_threads,BPCellsDelayedAbind-method}
\alias{set_threads,ColBindMatrices-method}
\alias{set_threads,RowBindMatrices-method}
\alias{set_threads,ANY-method}
\alias{rbind2,ANY,BPCellsMatrix-method}
\alias{rbind2,BPCellsMatrix,ANY-method}
\alias{cbind2,ANY,BPCellsMatrix-method}
\alias{cbind2,BPCellsMatrix,ANY-method}
\alias{binarize,ANY-method}
\alias{Compare,BPCellsMatrix,ANY-method}
\alias{Compare,ANY,BPCellsMatrix-method}
\alias{convert_mode,ANY-method}
\alias{mask_matrix,ANY-method}
\alias{expm1_slow,ANY-method}
\alias{Math,BPCellsArray-method}
\alias{Math2,BPCellsArray-method}
\alias{rank_transform,ANY-method}
\alias{[<-,BPCellsMatrix,ANY,ANY,BPCellsMatrix-method}
\alias{[<-,BPCellsMatrix,ANY,ANY,IterableMatrix-method}
\alias{[<-,BPCellsMatrix,ANY,ANY,matrix-method}
\alias{[<-,BPCellsMatrix,ANY,ANY,dgCMatrix-method}
\alias{transpose_axis,ANY-method}
\alias{internal-methods}
\alias{pmin2,BPCellsMatrix,vector-method}
\alias{pmin2,vector,BPCellsMatrix-method}
\alias{pmin2,BPCellsMatrix,DelayedArray-method}
\alias{pmin2,DelayedArray,BPCellsMatrix-method}
\alias{pmax2,BPCellsMatrix,vector-method}
\alias{pmax2,vector,BPCellsMatrix-method}
\alias{pmax2,BPCellsMatrix,DelayedArray-method}
\alias{pmax2,DelayedArray,BPCellsMatrix-method}
\title{House of internal methods}
\usage{
\S4method{DelayedArray}{BPCellsDelayedOp}(seed)

\S4method{/}{numeric,BPCellsMatrix}(e1, e2)

\S4method{\%\%}{numeric,BPCellsMatrix}(e1, e2)

\S4method{\%\%}{BPCellsMatrix,numeric}(e1, e2)

\S4method{\%/\%}{numeric,BPCellsMatrix}(e1, e2)

\S4method{\%/\%}{BPCellsMatrix,numeric}(e1, e2)

\S4method{set_threads}{BPCellsDelayedAbind}(object, threads = 0L)

\S4method{set_threads}{ColBindMatrices}(object, threads = 0L)

\S4method{set_threads}{RowBindMatrices}(object, threads = 0L)

\S4method{set_threads}{ANY}(object, ...)

\S4method{rbind2}{ANY,BPCellsMatrix}(x, y, ...)

\S4method{rbind2}{BPCellsMatrix,ANY}(x, y, ...)

\S4method{cbind2}{ANY,BPCellsMatrix}(x, y, ...)

\S4method{cbind2}{BPCellsMatrix,ANY}(x, y, ...)

\S4method{binarize}{ANY}(object, ...)

\S4method{Compare}{BPCellsMatrix,ANY}(e1, e2)

\S4method{Compare}{ANY,BPCellsMatrix}(e1, e2)

\S4method{convert_mode}{ANY}(object, mode)

\S4method{mask_matrix}{ANY}(object, mask, invert = FALSE)

\S4method{expm1_slow}{ANY}(x)

\S4method{Math}{BPCellsArray}(x)

\S4method{Math2}{BPCellsArray}(x)

\S4method{rank_transform}{ANY}(object, axis = NULL, offset = TRUE, ...)

\S4method{[}{BPCellsMatrix,ANY,ANY,BPCellsMatrix}(x, i, j, ...) <- value

\S4method{[}{BPCellsMatrix,ANY,ANY,IterableMatrix}(x, i, j, ...) <- value

\S4method{[}{BPCellsMatrix,ANY,ANY,matrix}(x, i, j, ...) <- value

\S4method{[}{BPCellsMatrix,ANY,ANY,dgCMatrix}(x, i, j, ...) <- value

\S4method{transpose_axis}{ANY}(object, mode)

\S4method{pmin2}{BPCellsMatrix,vector}(e1, e2)

\S4method{pmin2}{vector,BPCellsMatrix}(e1, e2)

\S4method{pmin2}{BPCellsMatrix,DelayedArray}(e1, e2)

\S4method{pmin2}{DelayedArray,BPCellsMatrix}(e1, e2)

\S4method{pmax2}{BPCellsMatrix,vector}(e1, e2)

\S4method{pmax2}{vector,BPCellsMatrix}(e1, e2)

\S4method{pmax2}{BPCellsMatrix,DelayedArray}(e1, e2)

\S4method{pmax2}{DelayedArray,BPCellsMatrix}(e1, e2)
}
\arguments{
\item{seed}{A \link[=BPCellsDelayedOp-class]{BPCellsDelayedOp} object.}

\item{e1, e2}{One of \code{x} or \code{y} must be \link[=BPCellsMatrix-class]{BPCellsMatrix}
object, and the another can be a \link[=BPCellsMatrix-class]{BPCellsMatrix} object
or any objects can be converted into \link{BPCellsSeed} object.}

\item{object}{A \link{BPCellsMatrix} object with a seed slot of
\link[=BPCellsDelayedOp-class]{BPCellsDelayedAbind} object, usually derived from
\link[=BPCells-bind]{bind} operators.}

\item{threads}{Set the number of threads to use for sparse-dense multiply and
\link[BPCells:matrix_stats]{matrix_stats}.}

\item{...}{Additional arguments to specific methods.}

\item{x, y}{See method signature.}

\item{mode}{Storage mode of BPCells matrix, one of \code{uint32_t} (unsigned
32-bit integer), \code{float} (32-bit real number), or \code{double} (64-bit real
number). R cannot differentiate 32-bit and 64-bit real number, so
\link[=BPCellsSeed-class]{type} method always return "double" for both \code{float}
and \code{double} mode.}

\item{mask}{A \link[=BPCellsMatrix-class]{BPCellsMatrix} object or any objects can
be converted into \link{BPCellsSeed} object.}

\item{invert}{A bool, indicates whether revert the mask.}

\item{axis}{Axis to rank values within. "col" to rank values within each
column, and "row" to rank values within each row. If \code{NULL}, will use the
storage axis of \code{object} (see \link{storage_axis}).  If \code{axis} specified is
different from the storage axis of \code{object}, \link{transpose_axis} will be
used to transpose the underlying storage order.}

\item{offset}{A bool, whether or not to add offset such that the rank of a 0
value is 0. Default: \code{TRUE}.}

\item{i, j}{Row and Column index.}

\item{value}{A \link[=BPCellsMatrix-class]{BPCellsMatrix} object or any objects can
be converted into \link{BPCellsSeed} object.}
}
\description{
Following methods are used by package internal, usually for messages purpose.
}
